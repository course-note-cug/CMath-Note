#import "@preview/touying:0.4.2": *
#import "@preview/ctheorems:1.1.2": *
#show: thmrules

#let s = themes.university.register(aspect-ratio: "4-3")
#let s = (s.methods.info)(
  self: s,
  title: [5. 贪心算法],
  author: [张桄玮(gwzhang\@cug.edu.cn)],
  date: datetime.today(),
  institution: [郑州一中(Legacy)],
)
#let (init, slides) = utils.methods(s)
#show: init
#let theorem = thmbox("theorem", "定理", fill: rgb("#c2dcc2"))
#let corollary = thmplain(
  "corollary",
  "推论",
  base: "theorem",
  titlefmt: strong
)
#let definition = thmbox("definition", "定义", inset: (x: 1.2em, top: 1em))

#let example = thmplain("example", "例子").with(numbering: none)
#let prob = thmplain("prob", "问题", inset: (x: 1.2em, top: 1em, bottom:1em)).with(fill: 
rgb("#dfebdf")).with(numbering: none)

#let proof = thmproof("proof", "证明")

#let (slide, empty-slide) = utils.slides(s)
#show: slides


= 类似背包的问题

== 一个特殊的凑硬币问题
#prob[
  某人带着3种面值的硬币, 分别是1, 2, 5元. 数量不限. 需要支付$M$元, 问怎样支付需要的硬币最少?
]

- 第一节讲过任意的面值的递归做法

策略: 首先拿出面额最大的数凑(5元); 然后是面额中等的(3元); 最后是面额最小的(1元). 

为什么? 大的可以用小的 "表示"

- $1+1=2$;
- $2+2+1=5$.

如果要用小的, 肯定能用大的替换出来. (交换论证)

带来的潜在的麻烦: 不能推广

- 不能得到最优解的情况: $1,2,4,5,6;$ 凑出9元; 
  - $9=5+2+4=6+1$;

- 不能得到解的: 上述算法说凑不出! 但是$9=5+2+2$

思考题: 什么样的硬币组合能够用这个算法求解?(有点难)
- 硬币的面额是$c^0, c^1, c^2, ..., c^k$ 贪心算法总是可以找到最优解
- 还有别的情况吗? (Hard)

== 背包装载问题

#prob[
  给出$n$个物品, 第$i$个物品的质量为$w_i$, 选择尽可能多的物品, 使得总质量不超过$C$. 
]


- 观察: 装重的物品没有装轻的物品划算. 
  - 如何形式化地考虑这个问题?

- 策略: 把物品从小到大排序, 依次选择每个物体, 直到装不下为止. 

- 如何证明这个内容是正确的?

#proof[
  假设不是按照这种方法选取的, 而是用的别的方法. 
  - 找到不是按照这个排序的第一个东西
  - 把它换为新的东西就得到了更优的解答!

]

== 部分背包问题

#prob[
  有$n$个物体, 第$i$个的物体重量为$x_i$, 价值为$v_i$, 在总重量不超过$C$的情形下让总价值尽可能高. 
  - 每一个物品可以拿走一部分
  - 价值和重量按照比例计算
]

Attempts:

- 拿重的? 不一定(占满空间);
- 拿轻的? 不一定(价值太小);
- 考虑$"价值" div "质量"$? (看起来不错)

策略: 按照$"价值" div "质量"$排序, 从大往小选择

#proof[
  - 假设物品集合$S={W_1,W_2,...,W_n}$已经按$"价值" div "质量"$从小到大排好序了
  - 全局最优解是: $S(i)={W_i_1,W_i_2,...,W_i_n}$. $W_i_1$, $W_i_2, ..., W_i_n$是有序的. 对于贪心选择而言, 总是会优先选择 $W_n$ 的物品, 当$W_n$没有后, 再选择$W_(n-1)$ 
    - 如果$W_i_n = W_n$ 问题已经得证. 因为, 我们的最优解$S(i)$中, 已经包含了贪心选择. 只要继续归纳下去, $W_i_(n-1)$ 就是 $W_(n-1)$
    - 假设存在一个最优解，在这个解中我们没有尽可能多地拿取物品 $i$，并且假设我们的背包已经满了（如果没有满，只需添加更多的物品 $i$ 即可）。由于物品 $i$ 具有最高的价值与重量比，那么在我们的背包中一定存在一个物品 $j$，使得 $v_j/w_j < v_i/w_i$。我们可以从背包中取出重量为 $x$ 的物品 $j$，并且可以将重量为 $x$ 的物品 $i$ 放入背包中（因为我们取出了 $x$ 重量，同时放入 $x$ 重量，因此仍然在容量范围内）。背包的价值变化为 $x  v_i/w_i - x v_j/w_j = x ( v_i/w_i - v_j/w_j ) > 0$，因为 $v_j/w_j < v_i/w_i$。

因此，我们得出矛盾，因为我们最初假设的“所谓”最优解实际上可以通过取出一些物品 $j$ 并添加更多的物品 $i$ 来改进。因此，这不是最优的。
]

另一个问题: 你为什么能够分阶段考虑问题? (i.e. 为什么最优的解能够组合出最优的解?)

- 不那么优的解肯定无法生成一个最优解

#prob[
  那么如果限定了每一个物品要么全拿走, 要么全不拿, 有没有贪心算法?
]

- 没有了, 似乎任何策略都没有办法完成
- 必须exhaustive地遍历所有情况

== 乘船问题

#prob[
  有$n$个人, 第$i$个人的重量为$w_i$. 每艘船最大载重量为$C$. 每船最多只能承载2个人. 用最少的船装载所有人. 
]


考虑最坏的情况

- 最轻的两个人也坐不了一艘船 $->$ 每个人占据一条船
- 如果能坐一艘船, 让两个人一起坐这艘?
  - 仔细考虑: 两个人一艘船, 可能还有 "容量的浪费"
  - 最小化这个?

从小到大, 体重最轻的人$i$先上船, 然后再剩余可以坐船的人中选一个最大的人$j$. 

声称: 最小化每艘船中浪费的空间, 就会最小化船的数量. 

#proof[
  假设这个方案不是最好的. 而是另有方案

  - Case 1: $i$不合任何人同坐一艘船. 但是完全可以把$j$拉过来坐, _不会减少_船的个数
  - Case 2: $i$ 和另一个人 $k$ 同船, 完全可以把$k$和$j$交换, 我的船也不会超重, 所以解不一定变得更差
]

- 贪心策略并不丢失最优解
  - 并不会变得更差就可以了. 不一定要说明一定会变得更优. 

== #link("https://www.luogu.com.cn/problem/P4995")[P1094 纪念品分组]

#prob[
  他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。分组的数目最少。
]


= 区间的例子

== 选择不相交的区间

#quote[
  我们是在结局问题, 不是套公式套模板, 而是理解问题的结构!
]

#prob[
  数轴上面有$n$个开区间$(a_i,b_i)$. 选择尽量多的区间, 使得区间两两没有公共点. 
]

观察1: 如果区间 $x$ 包含区间$y$, 那么肯定应该选 $y$. 

- 区间数目不会减少
- 还能留更多的位置给别的区间选择


大家会给出怎样的贪心策略?

- 最短的活动优先?

策略: 按照活动结束的时间排序, 一定要选第一个区间. 

为什么? 


#proof[
  现在的区间: $b_1<=b_2<=...<=b_n$

  考虑$a_1, a_2$的大小关系:

  - $a_1>a_2$, 区间2包含区间1, 无论如何都不会选择区间2. 
    - 只要任何一个$i$满足$a_1>a_i$都不考虑(不明智)
  - $a_1<=a_2<=a_3<=a_4<=...$ 
    - 区间2和区间1完全不相交: 不会有任何影响; 
    - 区间2与区间1有一部分重叠: 区间1的开头到区间2的开始这段是不受影响的; 
      - 实际有用的区间: [区间2的开头, 区间1的结尾]
      - 这样一来若选择区间2就相当于选了一个被包含的大区间!!

  综上所述, 一定要选择第一个区间. 
]

策略(继续): 在选择完第一个区间之后, 把所有与第一个相交的内容排除在外, 记录上一个选择的区间编号, 再次进行选取. 

问答: 试说出刚刚过程的子问题是什么. 

#figure(
  image("figs/greedy/selection.png")
)

== 区间选点问题

#prob[
 数轴上面有$n$个闭区间$[a_i,b_i]$. 选择尽量少的区间, 使得每个区间内至少有1个点(不同区间包含的点可能是同一个). 
]

定义: 一个区间已经被 "满足" := 这个区间里面已经选择了一个点. 

观察: 小区间被满足 $->$ 大区间一定被满足了!

- 首先按照$b_i$从小到大排序(和上题目一样)
  - 起点相同的话, 小的区间排在前面($a$递增)
- 考虑第一个区间: 选择哪个点?
  - 注意已经按照$b_i$排好序了
  - 取得最后一个点(把中间的点挪到后面会让更多的区间满足)


== 区间覆盖问题

#prob[
 数轴上面有$n$个闭区间$[a_i,b_i]$. 选择尽量少的区间, 覆盖一条指定的线段$[s,t]$. 
]

观察: 每个区间在$[s,t]$以外的部分没有影响, 可以直接砍掉

还是观察: 和刚刚相反, 小区间的存在毫无意义! 

- 按照起点$a_i$排序, 如果1的起点不是$s$, 无解; (总有一段覆盖不上去)
- 否则选择起点为$s$的最长区间$[a_i, b_i]$. 
- 选择后, 忽略所有的在$b_i$前的部分. 


= Huffman 树和贪心策略

== 需求: 压缩文件

```
THISSENTENCECONTAINSTHREEASTHREECSTWODSTWENTYSIXESFIVEFST HREEGSEIGHTHSTHIRTEENISTWOLSSIXTEENNSNINEOSSIXRSTWENTYSEV ENSSTWENTYTWOTSTWOUSFIVEVSEIGHTWSFOURXSFIVEYSANDONLYONEZ
```

- 做映射: 字母 $->$ 0,1 编码的代码

要求
- 尽可能短: 出现的越频繁 $->$ 对应的编码越短
- 可以恢复: 没有一个编码的是另一个编码的前缀
  - 例如, $a=10,b=101$不可以!

形式化的描述
- 要对一个写在$n$字符字母表中的消息进行编码，我们希望编码后的消息尽可能短。
- $f[1..n]$ 记录了每一个频率的出现次数
- 寻找一个前缀树, 最小化消息的长度. 

== 例子

```
THISSENTENCECONTAINSTHREEASTHREECSTWODSTWENTYSIXESFIVEFST HREEGSEIGHTHSTHIRTEENISTWOLSSIXTEENNSNINEOSSIXRSTWENTYSEV ENSSTWENTYTWOTSTWOUSFIVEVSEIGHTWSFOURXSFIVEYSANDONLYONEZ
```

往左边走是0, 往右边走是1. 

#figure(
  image("figs/greedy/pref-tree.png", width: 80%),
) 


== 最优编码问题

#prob[
  给出$n$个字符的频率$c_i$, 给每一个字符赋予一个0, 1编码串. 要求任意一个编码不是另一个字符编码的前缀, 而且编码后总长度(每个字符的频率与编码长度乘积的总和)尽量小. 
]

对应关系: 满足上述的内容的东西是可以表示为一个二叉树
- 叶子节点是字符
- 经过的路径是字符对应的编码

问题转化为: 如何构造一棵最优二叉编码树? 

== 构造最优编码树

策略: 
- 把每个字符看做一个单节点的子树放到树集合中, 
  - 每棵子树的权值等于对应字符的频率. 
- 每次取当前集合中权值最小的两元素; 构造成一个新树. 新树的权值等于原来的权值之和. 

1. (初始的时候对吗?) 设$x, y$是两个出现频率最小的字符, 存在前缀码使得$x,y$的长度相等, 只有最后一位不同. 

#proof[
  假设不是这样的, 可以把出现次数最小的东西换过来, 就会得到更小的值. 

  #figure(
    image("figs/greedy/prf-huffman.png", width: 80%),
  ) 

  即, 不妨设$f(x)<=f(y), f(a)<=f(b)$, 根据假设条件有$f(x)<=f(a), f(y)<=f(b)$. 如果$x!=a$, 就交换$x <-> a$, 如果$y!=b$, 就交换$y<->b$. 这样出现更多的就变浅了, 不会变得更糟糕. 
]

2. (原问题最优解包含子问题的最优解) 如果$T$是字符集$C$的一个最优编码树, $x,y$是$T$的两个互为兄弟的叶子节点, $z$是$x,y$的父节点, 如果把$z$看做频率为$f(z)=f(x)+f(y)$的字符, 那么$T'=T-{x,y}$是字符集$C'=C-{x,y} union {z}$的最优编码树.

#proof[
  - $T'$的编码长度为$L$, 字符${x,y}$对应深度为$h$, 如果把$x,y$拆成两个的话, 长度变为

  $L-(f(x)+f(y)) &h+(f(x)+f(y))(h+1)\
  &=L+f(x)+f(y)$

  因此只有$T'$是$C'$的最优编码树, 才可以整个最优.

]

- 原问题的最优解包含子问题的最优解 $=>$ 最优子结构(optimal substructure)

= 问题的结构

== 直观感受

从大的集合里面
- 选出一些东西
- 排一个顺序

达成我们的某个目标(最小化某个东西)

问题的另一种感知方式

- 正常思路: 构造一个某算法, 使其产生最优解
- 奇怪的思路: 可以先随便找一个顺序, 然后如果更换顺序的过程中产生了更优解, 就相当于有了个更好的解; 直到再次交换无法使目标变得更小. 

例如: 冒泡排序

```
for (int i = 0; i < n; i++)
    for (int j = i + 1; j < n; j++)
        if (a[i] > a[j]) {
            swap(a[i], a[j]); // 铲除逆序对
        }
```

实际上表达的是

```
while (!is_sorted(a)) {
    // 返回任意 i < j, a[i] > a[j]
    auto [i, j] = find_unordered(); 
    swap(a[i], a[j]);
}
```

- 如果不存在$(i<j) and (a_i > a_j)$, 一定排好序了
- 不存在$a_i>a_i+1$, 一定排好序了 $<-$冒泡排序做的事情

== 交换论证

回顾刚才: 提出一个策略$P$, 采用反证法

- 假设还有一个 "更优的解答"...
- 把 "更优的解答" 的某个东西换掉, 按照我这个策略的某个东西填上
- 得到 "更更优" 的解答(矛盾)

或者说贪心法的原理:

- 分成了若干个阶段, 子阶段最优会让全部的最优(最优子结构)
- 我这个策略在任何的情况下并不会让解答变坏(可以贪心选择)

== 覆盖一类问题的理论

#definition[(拟阵理论) 拟阵是一个满足下列条件的二元组$(S,L)$

- $S$是一个有穷集合. (如刚刚硬币问题里面的$S={1,2,5,10}$)
- $L$是$S$的非空子集构成的集合的一个子集. $L$中的元素被称为独立集 (如$L={{1},{2},{5},{1,2},{1,5},{2,5}}$, 有6个独立集).
- $M$满足遗传性: 对于独立集$B$, 若$B in L, $则$forall A subset B$, 有$A in L$. (如$B={2,5}, A={2}, A in L$).
- $M$满足扩展性: $forall A in L, B in L, |A|<|B|, (exists x in (B-A), "s.t." A union {x} in L)$.
  - 如$A={2}, B={2,5}, x=2,A union {2}={2,5} in L$.

]

== 有点眼熟

- 遗传性: 刚刚的 "小区间可以被满足, 那么大区间一定可以"
- 扩展性: 可以由一个 "已经怎么决定的区间" 的最优解扩展到了大一点的 "还没决定好" 的区间. 

贪心的结果: 为$S$中的每一个元素设定一个权值$w(i)$, 最优化这个
- 最大独立集: 如果一个独立集合不能再扩充了, 就称为最大独立集. 

#theorem[
  同一拟阵的最大独立集的元素个数相同. 
]

#proof[
  若不然, 假设$|A|, |B|$是两个大小不同的独立集, 且不妨设$|A|<|B|$. 那么根据交换性,$A$是可扩充的, 不满足最大独立集的定义. 矛盾!
]

== 贪心与拟阵

贪心的结果: 为$S$中的每一个元素设定一个权值$w(i)$, 最优化这个
- 对于$S$的子集$A$构成的权值$w(A)=sum_(x in A)w(x)$. 
- 权值最大独立集一定是极大独立集. 怎么找?

还是贪心!

```
Greedy(拟阵<S, L>, 权值w)
  A={}
  sort S by w // 把S内的元素x按照权值w(x)从大到小降序排序
  for x in S
    if(A ∪ {x} ∈ L)
      A=A ∪ {x}
  return A
```

- 能够构造成拟阵的一定可以使用贪心
- 但是不能的有时候也可以用...

= 练习题

== #link("www.luogu.com.cn/problem/P1181")[P1181 数列分段]

#prob[
  对于给定的一个长度为 $N$ 的正整数数列 $A_i$, 现要将其分成连续的若干段, 并且每段和不超过 $M$ (可以等于 $M$ ), 问最少能将其分成多少段使得满足要求。
]

- 空间限制比较死, 所以肯定是能加一个进去就加一个进去了.

== #link("www.luogu.com.cn/problem/P1208")[P1208 混合牛奶]

#prob[
 M乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外每位奶农每天能提供的牛奶数量是一定的。每天M乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。给出M乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。每天所有奶农的总产量大于M乳业的需求量。
]

策略: 每次选单价最小的，直到完成任务


== #link("https://www.luogu.com.cn/problem/P4995")[P4995 跳跳]

#prob[
  有一堆高矮不同的石头, 第$i$块高度为$h_i$. 地面的高度为$h_0=0$. 从第$i$块跳到第$j$块耗费的体力值为$(h_i-h_j)^2.$ 要求跳到每个石头上面各1次, 耗费最多的体力值. 问跳跃序列.  
]

策略: 考虑相邻两次差值尽可能大?
- 最左一下, 最右一下, 第二左一下, 第二右边一下...

== #link("https://www.luogu.com.cn/problem/P1199")[P1199 三国游戏]

#prob[
  《三国》的游戏中, 共有$N>=4,N"是偶数"$个武将. 两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。

  游戏开始, 小涵和计算机要从自由武将中挑选武将组成自己的军队, 规则如下：小涵先从自由武将中选出一个加入自己的军队, 然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照 "小涵 $->$ 计算机 $->$ 小涵 $-> dots$" 的顺序选择武将, 直到所有的武将被双方均分完。然后, 程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武, 拥有更高默契值的一对武将组合获胜, 表示两军交战, 拥有获胜武将组合的一方获胜。

  计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。
]

== UVA1615 高速公路

#prob[
1. 高速公路是从原点 $(0, 0)$ 到 $(L, 0)$ 的线段。
2. 村庄在平面上标记为点集 $(x_i, y_i)$。
3. 每个村庄到最近的天桥的欧几里得距离不超过 $D$。

目标：最少需要修建多少个天桥，使得每个村庄到最近天桥的距离不超过 $D$。
]

类似与区间覆盖问题

- 区间是什么?   

== CF1995C 平方

#prob[
- 给一个数组$a$, 每次可以选择一个下标, 把那个数平方. 
- 最少多少次, 使得数组单调不降?

范围: $n <= 2 times 10^5; a_i <= 10^6$
]

- 前面的内容应该尽可能的小, 遇见不是单调的内容元素就去平方它

这是因为 $x,y>0=> x^2>y^2$

- 反过来, $x^2>y^2 => |x|> |y|.$ 根据$x, y>0$, 意味着$x>y$

问题: 
- $a_i<=10^6$, 这平方两下不就爆炸了?

== 补充知识: 对数的发明

计算很大的数: 16A.D.的欧洲天文学

- 天文学蓬勃发展, 计算成为了主要的障碍. (数据非常不友好)
- Scotland的Napir说乘法有简单的方法. 

#quote[数据那么大, 干脆用基于某个数的指数就好了嘛!]

- 2的几次方

$
&1 quad &2 quad    &3 quad &4 quad &5 quad & 6 quad & 7 \
&2 quad &4 quad  &8 quad &16 quad&32 quad &64 quad & 128quad 
$

- 这样便可以把乘法换成加法:
  - $8 times 16=2^3 times 2^4=2^7=128$

- 问题: 3怎么用 "2的几次方" 表示?
  - 大概写成1.584926... 是个无理数
  - 2的1.584926次方大约等于3

当时: 花费了20年写了一本书

这就是为什么我们要关注$2^?=3$.

#quote[
  这个工具的诞生使得天文学家的寿命加倍.
]

我们更关注它的"性质"而不是"结果", 因此我们可以用一个符号来代表它.

"我们给他起一个$?=log_2 3$". 可以不用写 $log_2^3$.

#figure(
  image("figs/greedy/log-book.png", width: 60%),
) 

为什么叫对数?
- 表"对着"的那个东西才能算. 
- $m=:log_a b$ 意味着 $a^m=b$

意思是: $a$的多少次方等于$b$? 那个答案就是$m$. 
- $a$在底下, 右边$a$也在底下. $a>0, a!= 1$. 
- $b$是真数, 就是那个结果, 真数大于0.
- $m$叫做对数
- 它们可以互换, 我们可以在不清楚的时候想想. 

快速回答: $log_2 8, log_27 9, log_16 8$;

计算机科学中经常使用以2为底的对数. 

== 补充知识: 对数的性质

1. 废话恒等式: $a^(log_a b)=b$. 
  - 比如$8=2^3=3^(log_2 8)$

2. 关于1: $log_a 1=0; log_a a=1(a>0,a!=1)$
3. 运算(优先级高于乘法)
$
log_a M+log_a N=log_a M N \
log_a M- log_a N=log_a (M/N) \ 
log_a M^b=b log_a M
$

#proof[
  方法就是化成熟悉的熟悉的指数形式; 参见高中课本. 
]

为什么复杂度我们会说$log n$级别的而不是$log_2 n$级别的?
- 对数之间 "增长得差不多快"
- 实际上不同底数的对数增长只是差一个常数!

考虑$log_a M ~ log_b M$, 改成指数形式: 

$
a^x=M, b^y=M, a^x=M=b^y
$

使用废话恒等式: 
$
b^(log_b a^x)=b^(x log_b a)=b^x ==>y=  x log_b a
$

用对数的记号表示: $log_b M=log_a M log_b M$, 也就是
$
log_a M=(log_b M)/(log_b a)
$

== 数学素养(Mathematical Maturity)

#figure(
  image("figs/greedy/mm.png", width: 70%),
) 

== 回到刚刚的练习题

感觉 "满足某种情况", 但是难找规律?

数学符号来这里理理头绪! 

- 假设对$a_(i-1)$操作$k_(i-1)$次, $a_i$操作$k_i$次
- 满足条件: $a_(i-1)^2^(k_i-1) <= a_i^(2^(k_i))$
- 幂次难以处理, 两边取对数把东西丢到前面来: $log_2 a_(i-1)^(2^(k_i-1))<=log_2 a_i^(2^(k_i))$
- ...
- $k_(i-1)+log_2 log_2 a_(i-1) -log_2 log_2  k_i <=k_i$

于是可以由$k_(i-1)$推出$k_i$. !